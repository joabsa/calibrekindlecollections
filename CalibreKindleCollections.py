'''
A simple script for handling collections on the Amazon Kindle.

The Kindle is a great reading device, unfortunately so far it is rather painful to use it for a large collection of documents -  for example when dealing with many research papers. 

Uses the metadata.calibre file generated by Calibre.
 
As Amazon doesn't seem to support this functionality yet, this is a hack which also requires that the Kindle be restarted to update the system. This is quite annoying, but there doesn't seem to be another way until Amazon releases its `Kindle Development Kit`. At which point this script will hopefully become obsolete.


Usage

$python2.6 CalibreKindleCollections.py [options]

Use the line below to find the available options

$python2.6 CalibreKindleCollections.py -h


Note that if the script is saved in the root folder of the Kindle (e.g. /Volumes/Kindle), the mount point is not necessary. 

Please feel free to use and extend the script in any way you want. If you already have a valued collection of collections, it might also be a good idea to backup this file before you give this a try.
'''

import sys,os,json,time
from hashlib import sha1
from optparse import OptionParser


# Relative path to collection json file
COLLECTIONS = 'system/collections.json'
# Relative path to documents folder
CALIBRE = 'metadata.calibre'

# for the computation of the sha1 identifier
KINDEL_ABS = '/mnt/us'

# Dictionary for storing collections
kindleC = {}
calibreC = {}

# Dictionary for command-line options
options = {}

def setup():
    ''' 
    In case the script is not run in the root folder of the Kindle device, the Kindle Mount Point has to be updated because relative paths won`t work anymore 
    '''
    global COLLECTIONS,CALIBRE,options

    # parse commmand line for options
    parser = OptionParser()
    parser.add_option("--nt","--no-tags", "--notags", action="store_false", dest="useTags", default=True, help="Do not use tags to create collections")
    parser.add_option("--na","--no-authors", "--noauthors", action="store_false", dest="useAuthors", default=True, help="Do not use authors to create collections")
    parser.add_option("--mc","--min-count", "--mincount", action="store_false", dest="minCount", default=2, help="Minimum number of books required to create a collection (default 2). Already existing collections with less books are kept.")
    # change default for your use. use '' if u want to set it completely from command line
    parser.add_option("--et", "--exclude-tags",dest="excludeTags", default = 'kindle,2kindle', help="Exclude the comma separated tags when creating collections")
    parser.add_option("-m","--mnt", dest="mntPoint", default=".", help="Required if script is not run from the root folder of Kindle.")
    (options,args) = parser.parse_args()    
    options.excludeTags = options.excludeTags.split(',')
    
    # Use the mount point 
    COLLECTIONS = os.path.join(options.mntPoint,COLLECTIONS)
    CALIBRE = os.path.join(options.mntPoint,CALIBRE)
    
def loadCalibre():
    ''' Loads/Transform Calibre metadata in dictionary '''
    global calibreC,options
    try:
        cf = open(CALIBRE,'r')
        calibreC = json.load(cf)
        cf.close()
      
        colls= {}
	    
        for book in calibreC:
            authors = book['authors']
            series = book['series']
            lpath = book['lpath']
            title = book['title']
            tags = book['tags']


            if series != None:
                if series not in colls:
                    colls[series] = { 'collName': series, 'collType': 'series', 'authors': [], 'lpaths': [], 'titles': [] }
                for author in authors:
                    if author not in colls[series]['authors']:
                        colls[series]['authors'].append(author)
                colls[series]['lpaths'].append(lpath)
                colls[series]['titles'].append(title)
            elif options.useAuthors == True:
                for author in authors:
                    if author not in colls:
                        colls[author] = { 'titles': [], 'collName': author,'collType': 'author', 'authors': [author], 'lpaths': [] }
                colls[author]['lpaths'].append(lpath)
                colls[author]['titles'].append(title)


            if options.useTags == True:
                for tag in tags:
                    if tag not in options.excludeTags:
                        if tag not in colls:
                            colls[tag] = { 'collName': tag, 'collType': 'tag', 'authors': [], 'lpaths': [], 'titles': [] }
                        for author in authors:
                            if author not in colls[tag]['authors']:
                                colls[tag]['authors'].append(author)
                        colls[tag]['lpaths'].append(lpath)
                        colls[tag]['titles'].append(title)

        
        calibreC = colls.values()

    except Exception, err:
        sys.stderr.write('ERROR loadCalibre: %s\n'%str(err))
        exit()
    
def loadCollections():
    ''' Loads Kindle collections in dictionary '''
    global kindleC
    try:
        cf = open(COLLECTIONS,'r')
        kindleC = json.load(cf)
        cf.close()
    except:
        print 'loadCollections'
        print 'WARNING: %s could not be loaded. Creating a new version.'%COLLECTIONS
        
def saveCollections():
    ''' Dump kindle collections dictionary back into json file '''
    cf = open(COLLECTIONS,'wb')
    json.dump(kindleC,cf)
    cf.close()


def lastAccess():
    ''' Returns a lastaccess value in milliseconds '''
    return int(time.time()*1000)

def updateCollections():
    '''
    Calibre data is traversed each book encountered is added to a collection with the name of
    each author and series (if defined).
    '''
    for coll in calibreC:
        lpaths = coll['lpaths']
        authors = coll['authors']
        collName = coll['collName']
        collType = coll['collType']
        titles = coll['titles']

        # create/get collections names for the following:
        #   author with multiple books, 
        #   series with one author, 
        #   series with multiple authors
        collInKindle = False
        cName = '%s@en-US'%(collName)
        if cName in kindleC:
            collInKindle = True
        elif collType == 'series':
            for author in authors:
                tempName = collName + " - " + author
                tName = '%s@en-US'%(tempName)
                if tName in kindleC:
                    collInKindle = True
                    cName = tName
                    break
            if not collInKindle and len(authors) == 1:
                tempName = collName + " - " + authors[0]
                cName = '%s@en-US'%(tempName)
                if cName in kindleC:
                    collInKindle = True
                
            
        # add books if there is more than one book in the collection
        if collInKindle or len(lpaths) >= options.minCount:
            
            # create the kindle collection if it does not exist and update access time
            if not collInKindle:
                kindleC[cName] = {'items':[], 'lastAccess':lastAccess()}
            else:
                kindleC[cName]['lastAccess'] = lastAccess()


            # add the paths to the books for the collection
            for lpath in lpaths:
                # determine the kindle specific absolute path
                absPath = '%s/%s'%(KINDEL_ABS,lpath)
                
                # compute the unique identifier, kindle uses the sha1 hashcode preceded by a * 
                # the device specific absolute path is used, e.g. '/mnt/us/documents/research/test.pdf'
                asin = '*%s'%sha1(absPath).hexdigest()

                # if the document is not already in the collection we add it
                if asin not in kindleC[cName]['items']:
                    kindleC[cName]['items'].append(asin) 
                
            # print a description of the collection 
            collDesc = '%s:\n%s\n'%(cName[0:cName.find('@en')],'\t'+'\n\t'.join(titles))
            print collDesc.encode('utf-8')

if __name__ == '__main__':

    setup()
    
    # Check if path are correct
    if not (os.path.exists(COLLECTIONS) and os.path.exists(CALIBRE)):
        print 'ERROR: unknown path to Kindle mounting point. Please set `%s` to correct path (e.g. /Volumes/Kindle)'%(options.mntPoint)
        sys.exit() 
        
    # Load collections
    loadCalibre()
    loadCollections()    
    # Add new files to the collection dictionary 
    updateCollections()    
    # Save updated collections back into json
    saveCollections()
    
    # display reminder to restart kindle 
    print 'REMINDER: COLLECTIONS WILL NOT BE UPDATED UNLESS YOU RESTART YOUR KINDLE NOW! HOLD THE SWITCH FOR 20 SECONDS AND THEN RELEASE. THEN WAIT 20 SECONDS; THE SCREEN WILL FLASH AND THEN THE DEVICE WILL RESTART' 
