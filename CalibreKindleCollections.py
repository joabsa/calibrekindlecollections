'''
A simple script for handling collections on the Amazon Kindle.

The Kindle is a great reading device, unfortunately so far it is rather painful to use it for a large collection of documents -  for example when dealing with many research papers. 

Uses the metadata.calibre file generated by Calibre.
 
As Amazon doesn't seem to support this functionality yet, this is a hack which also requires that the Kindle be restarted to update the system. This is quite annoying, but there doesn't seem to be another way until Amazon releases its `Kindle Development Kit`. At which point this script will hopefully become obsolete.


Usage

$python2.6 CalibreKindleCollections.py [options]

Use the line below to find the available options

$python2.6 CalibreKindleCollections.py -h


Note that if the script is saved in the root folder of the Kindle (e.g. /Volumes/Kindle), the mount point is not necessary. 

Please feel free to use and extend the script in any way you want. If you already have a valued collection of collections, it might also be a good idea to backup this file before you give this a try.
'''

import sys,os,json,time
from hashlib import sha1
import logging
import argparse

########## Customize. Can also be modified through command line #############
noTags=True
noAuthors=False
noSeries=False

excludeTags='kindle,2kindle'
###########################################################################


# Relative path to collection json file
COLLECTIONS = 'system/collections.json'
# Relative path to calibre database
CALIBRE = 'metadata.calibre'
# Relative path to the documents folder
DOCUMENTS='documents'

# for the computation of the sha1 identifier
KINDLE_ABS = '/mnt/us'

# Dictionary for storing collections
kindleC = {}
calibreC = {}

# Dictionary for command-line options
options = {}

# logger for the application
log = logging.getLogger("app")

def setup():
    ''' 
    In case the script is not run in the root folder of the Kindle device, the Kindle Mount Point has to be updated because relative paths won`t work anymore 
    '''
    global COLLECTIONS,CALIBRE,options

    # parse commmand line for options
    parser = argparse.ArgumentParser(description='Create collections for books maintained by Calibre for the Kindle')
    parser.add_argument("--nt", "--notags", action="store_false", dest="createTags", default=not noTags, help="Do not use tags to create collections")
    parser.add_argument("--na", "--noauthors", action="store_false", dest="createAuthors", default=not noAuthors, help="Do not use authors to create collections")
    parser.add_argument("--ns", "--noseries", action="store_false", dest="createSeries", default=not noSeries, help="Do not use series to create collections")

    parser.add_argument("--et", "--excltags",dest="excludeTags", default = excludeTags, help="Exclude the comma separated tags when creating collections")

    parser.add_argument("-m","--mnt", dest="mntPoint", default=".", help="Required if script is not run from the root folder of Kindle.")
    parser.add_argument("-v","--verbose", dest="verbose", default=False, action="store_true", help="Show more information")
    parser.add_argument("-q","--quiet",dest="quiet",default=False,action="store_true",help= "Show less information")
    
    options = parser.parse_args()    
    options.excludeTags = options.excludeTags.split(',')
    
    
    options.minCount = 2

    # Use the mount point 
    COLLECTIONS = os.path.join(options.mntPoint,COLLECTIONS)
    CALIBRE = os.path.join(options.mntPoint,CALIBRE)

    # setup the logger
    if options.quiet:
        log.setLevel(logging.ERROR)
    elif options.verbose:
        log.setLevel(logging.DEBUG)
    else:
        log.setLevel(logging.INFO)

    ch = logging.StreamHandler()
    formatter = logging.Formatter("%(message)s")
    ch.setFormatter(formatter)
    log.addHandler(ch)

    log.debug("Log level: %s"%log.getEffectiveLevel())
    log.debug("Create tags: %s"%options.createTags)
    log.debug("Create authors: %s"%options.createAuthors)
    log.debug("Create series: %s"%options.createSeries)
    log.debug("Exclude Tags: %s"%options.excludeTags)
    log.debug("Kindle Folder: %s"%options.mntPoint)

    
def loadCalibre():
    ''' Loads/Transform Calibre metadata'''
    global calibreC,options
    try:
        cf = open(CALIBRE,'r')
        calibreC = json.load(cf)
        cf.close()
      
        colls= {}
	    
        for book in calibreC:
            lpath = book['lpath']

            title = book['title']
            tags = book['tags']
            authors = book['authors']
            series = book['series']
            series_index = book['series_index']

            if series_index != None:
                title = "%s "%series_index + title  

            # if the book is part of a series place it in the series
            # collection otherwise place it in the author's collection
            if series != None and options.createSeries:
                if series not in colls:
                    colls[series] = { 'collName': series, 'collType': 'series', 'authors': [], 'lpaths': [], 'titles': [] }
                for author in authors:
                    if author not in colls[series]['authors']:
                        colls[series]['authors'].append(author)
                colls[series]['lpaths'].append(lpath)
                colls[series]['titles'].append(title)
            elif options.createAuthors:
                for author in authors:
                    if author not in colls:
                        colls[author] = { 'titles': [], 'collName': author,'collType': 'author', 'authors': [author], 'lpaths': [] }
                colls[author]['lpaths'].append(lpath)
                colls[author]['titles'].append(title)


            if options.createTags:
                for tag in tags:
                    if tag not in options.excludeTags:
                        if tag not in colls:
                            colls[tag] = { 'collName': tag, 'collType': 'tag', 'authors': [], 'lpaths': [], 'titles': [] }
                        for author in authors:
                            if author not in colls[tag]['authors']:
                                colls[tag]['authors'].append(author)
                        colls[tag]['lpaths'].append(lpath)
                        colls[tag]['titles'].append(title)

        
        calibreC = colls.values()

    except Exception, err:
        log.error("loadCalibre: %s"%str(err))
        exit()
    
def loadCollections():
    ''' Loads Kindle collections in dictionary '''
    global kindleC
    try:
        cf = open(COLLECTIONS,'r')
        kindleC = json.load(cf)
        cf.close()
    except:
        print 'loadCollections'
        print 'WARNING: %s could not be loaded. Creating a new version.'%COLLECTIONS
        
def saveCollections():
    ''' Dump kindle collections dictionary back into json file '''
    cf = open(COLLECTIONS,'wb')
    json.dump(kindleC,cf)
    cf.close()


def lastAccess():
    ''' Returns a lastaccess value in milliseconds '''
    return int(time.time()*1000)

def updateCollections():
    '''
    Calibre data is traversed each book encountered is added to a collection with the name of
    each author and series (if defined).
    '''
    for coll in calibreC:
        lpaths = coll['lpaths']
        authors = coll['authors']
        collName = coll['collName']
        collType = coll['collType']
        titles = coll['titles']

        # create/get collections names for the following:
        #   author with multiple books, 
        #   series with one author, 
        #   series with multiple authors
        collInKindle = False
        cName = '%s@en-US'%(collName)
        if cName in kindleC:
            collInKindle = True
        elif collType == 'series':
            for author in authors:
                tempName = collName + " - " + author
                tName = '%s@en-US'%(tempName)
                if tName in kindleC:
                    collInKindle = True
                    cName = tName
                    break
            if not collInKindle and len(authors) == 1:
                tempName = collName + " - " + authors[0]
                cName = '%s@en-US'%(tempName)
                if cName in kindleC:
                    collInKindle = True
                
            
        # add books if there is more than one book in the collection
        if collInKindle or len(lpaths) >= options.minCount:
            
            # create the kindle collection if it does not exist and update access time
            if not collInKindle:
                kindleC[cName] = {'items':[], 'lastAccess':lastAccess()}
            else:
                kindleC[cName]['lastAccess'] = lastAccess()


            # add the paths to the books for the collection
            for lpath in lpaths:
                # determine the kindle specific absolute path
                absPath = '%s/%s'%(KINDLE_ABS,lpath)
                
                # compute the unique identifier, kindle uses the sha1 hashcode preceded by a * 
                # the device specific absolute path is used, e.g. '/mnt/us/documents/research/test.pdf'
                asin = '*%s'%sha1(absPath).hexdigest()

                # if the document is not already in the collection we add it
                if asin not in kindleC[cName]['items']:
                    kindleC[cName]['items'].append(asin) 
                
            # print a description of the collection 
            collDesc = '%s:\n%s\n'%(cName[0:cName.find('@en')],'\t'+'\n\t'.join(sorted(titles)))
            log.info(collDesc.encode('utf-8'))

if __name__ == '__main__':

    setup()
    
    # Check if path are correct
    if not (os.path.exists(COLLECTIONS) and os.path.exists(CALIBRE)):
        log.error("Unknown path to Kindle mounting point. Please correct path (e.g. /Volumes/Kindle) on the command line")
        sys.exit() 
        
    # Load collections
    loadCalibre()
    loadCollections()    
    # Add new files to the collection dictionary 
    updateCollections()    
    # Save updated collections back into json
    saveCollections()
    
    # display reminder to restart kindle 
    print 'REMINDER: COLLECTIONS WILL NOT BE UPDATED UNLESS YOU RESTART YOUR KINDLE NOW! HOLD THE SWITCH FOR 20 SECONDS AND THEN RELEASE. THEN WAIT 20 SECONDS; THE SCREEN WILL FLASH AND THEN THE DEVICE WILL RESTART' 
